For Project 3, I returned to the component request aspect of the site and connected the forms to the server. There are four points of interaction with the server in this part of the site: retrieving a list of tools and their votes, voting on a tool, making a new tool request, and removing a tool request. Retrieving the list of tools was accomplished in the last submission.

For voting on the tools I locate references to the ToolRequest via a tool ID in the URL and to the user via the request object, then chose to delete the ToolVote, creating it if it doesn't exist. This effectively toggles a vote every time `/vote/<tool id>` is accessed. I think it would be semantically better to put this logic in a POST to that URL instead of a GET, but this works perfectly for now.

For making tool requests I connected a form action in the template to a view that creates a ToolRequest from the form data in the POST request. This is very effective, however I chose not to follow Django's recommended form handling, instead choosing to manually extract and verify the data from the form. I found this to be easier for the purposes of this part of the application. I then added a link to remove a request if the logged-in user owns it, which also suffers like voting from being a GET request that modifies the database. In all of these I made use of the `get_object_or_404` Django shortcut for quick errors if the object didn't exist.